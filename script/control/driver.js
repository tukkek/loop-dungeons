import*as i from"./engine.js";import*as e from"./rpg.js";import*as s from"../model/dungeon/floor.js";import*as o from"../model/unit/chest.js";import*as r from"../model/unit/stairs.js";import*as a from"../view/map.js";import*as l from"../model/point.js";import*as n from"../view/sidebar.js";import*as u from"./mechanic/traversal.js";import*as t from"./audio.js";const f="Stopping auto-explore...";class h extends l.Point{constructor(o,e){super(o,e)}value(){return m.explore}validate(){for(let e of this.neighbors)if(e.validate(0,0,a.width,a.height)&&!i.floor.wall(e.x,e.y)&&!i.floor.seen.find(o=>o.equals(e)))return!0;return!1}get location(){return this}}var m={chest:3,stairs:2,explore:1},c=!1;function p(o=!1){c=!1,i.explore&&o&&x()}function d(o){var e,t=new PF.Grid(a.width,a.height);for(e of l.range(0,0,a.width,a.height)){var r=i.floor.tiles[e.x][e.y];t.setWalkableAt(e.x,e.y,r==s.empty)}var n=i.hero.location;return(new PF.AStarFinder).findPath(n.x,n.y,o.x,o.y,t)}function v(){var o,t=i.floor;let r=[];for(let e of t.units)0!=e.value()&&t.seen.find(o=>o.equals(e.location))&&0<d(e).length&&r.push(e);for(let e of t.seen)t.units.find(o=>o.location.equals(e))||(o=new h(e.x,e.y)).validate()&&r.push(o);0!=r.length&&(r.sort((o,e)=>o.value()-e.value()).reverse(),r=r.filter(o=>o.value()==r[0].value()),e.shuffle(r),r.sort((o,e)=>d(o).length-d(e).length),c=r[0])}function g(o,e){let t=!1;t=0==o&&1==e?"north":1==o&&0==e?"east":0==o&&-1==e?"south":"west",n.flash(document.querySelector("#"+t))}function x(o=f){n.log(o),n.explore(!1)}function w(){var o,e,t;i.explore&&!s.generating&&(3<=(o=i.hero).wounds?(n.log("Too hurt!"),p(!0)):(c&&!c.location.equals(o.location)||v(),c&&(g(e=(t=d(c)[1])[0]-o.x,t=t[1]-o.y),u.move(e,t),c)&&c.location.equals(o.location)&&(c instanceof r.Down&&c.climb(),p())))}function j(){t.listeners.push(w)}export{m as value,p as reset,w as turn,j as setup};